diff --git a/notebooks/Example-1.ipynb b/notebooks/Example-1.ipynb
index 0ef35a4..6118ee0 100644
--- a/notebooks/Example-1.ipynb
+++ b/notebooks/Example-1.ipynb
@@ -1,9 +1,1089 @@
 {
  "cells": [
+  {
+   "cell_type": "code",
+   "execution_count": 26,
+   "id": "ae510489-e60e-494e-ade6-470fc69977d0",
+   "metadata": {},
+   "outputs": [
+    {
+     "name": "stdout",
+     "output_type": "stream",
+     "text": [
+      "{'lateral_spacing': 0.01, 'vertical_spacing': 0.01, 'max_offset': 5.0, 'max_depth': 1.0, 'rec_spacing': 10, 'sou_spacing': 10, 'num_epochs': 250, 'num_neurons': 20, 'num_layers': 10, 'learning_rate': 0.001, 'model_type': 'seam', 'data_type': 'full', 'middle_shot': 'n', 'until_cmb': 'n', 'earth_scale': 'n', 'scale_factor': 10, 'reduce_after': 15, 'seed': 123, 'initialization': 'varianceScaling', 'plotting_factor': 1, 'rescale_plot': 'n', 'depth_shift': 'n', 'tau_multiplier': 3.0, 'initial_velocity': 4, 'zid_source': 5, 'zid_receiver': 0, 'explode_reflector': 'n', 'field_synthetic': 'n', 'v_multiplier': 3, 'activation': 'elu', 'num_points': 1.0, 'irregular_grid': 'n', 'xid_well': 5, 'last_vmultiplier': 5, 'nu_units': 'unitless', 'well_depth': None, 'exp_function': 'n', 'exp_factor': 1.0, 'exclude_topo': 'n', 'exclude_well': 'n', 'exclude_source': 'n', 'loss_function': 'mse', 'station_factor': 1.0, 'event_factor': 1.0, 'checker_size': 5.0, 'tau_act': 'None', 'empty_middle': 'n', 'factorization_type': 'multiplicative', 'causality_factor': 1.0, 'causality_weight': 'type_0', 'residual_network': 'n', 'velocity_loss': 'n', 'regular_station': 'n', 'data_neurons': 16, 'data_layers': 8, 'append_shot': 'n'}\n"
+     ]
+    }
+   ],
+   "source": [
+    "import wandb\n",
+    "import matplotlib.pyplot as plt\n",
+    "import pandas as pd\n",
+    "import numpy as np\n",
+    "import os\n",
+    "\n",
+    "from argparse import ArgumentParser   \n",
+    "from hcpinnseikonal.utils import *\n",
+    "from hcpinnseikonal.plot import *\n",
+    "\n",
+    "if __name__ == \"__main__\":\n",
+    "    \n",
+    "#     wandb.init(project=\"GFATT_PINNs-11-pytorch-surface-inversion\")\n",
+    "#     wandb.run.log_code(\".\")\n",
+    "\n",
+    "    parser = ArgumentParser(description=\"Chekcerboard Test\")\n",
+    "\n",
+    "    parser.add_argument(\n",
+    "        \"--lateral_spacing\",\n",
+    "        type=float,\n",
+    "        default=0.01,\n",
+    "        help=\"Lateral sampling.\",\n",
+    "    )\n",
+    "    parser.add_argument(\n",
+    "        \"--vertical_spacing\",\n",
+    "        type=float,\n",
+    "        default=0.01,\n",
+    "        help=\"Vertical sampling.\",\n",
+    "    )\n",
+    "    parser.add_argument(\n",
+    "        \"--max_offset\",\n",
+    "        type=float,\n",
+    "        default=5.,\n",
+    "        help=\"Maximum offset.\",\n",
+    "    )\n",
+    "    parser.add_argument(\n",
+    "        \"--max_depth\",\n",
+    "        type=float,\n",
+    "        default=1.,\n",
+    "        help=\"Maximum depth.\",\n",
+    "    )\n",
+    "    parser.add_argument(\n",
+    "        \"--rec_spacing\",\n",
+    "        type=int,\n",
+    "        default=10,\n",
+    "        help=\"Receiver sampling.\",\n",
+    "    )\n",
+    "    parser.add_argument(\n",
+    "        \"--sou_spacing\",\n",
+    "        type=int,\n",
+    "        default=10,\n",
+    "        help=\"Source sampling.\",\n",
+    "    )\n",
+    "    parser.add_argument(\n",
+    "        \"--num_epochs\",\n",
+    "        type=int,\n",
+    "        default=250,\n",
+    "        help=\"Epochs length.\",\n",
+    "    )    \n",
+    "    parser.add_argument(\n",
+    "        \"--num_neurons\",\n",
+    "        type=int,\n",
+    "        default=20,\n",
+    "        help=\"Neurons width.\",\n",
+    "    )\n",
+    "    parser.add_argument(\n",
+    "        \"--num_layers\",\n",
+    "        type=int,\n",
+    "        default=10,\n",
+    "        help=\"Layers depth.\",\n",
+    "    )\n",
+    "    parser.add_argument(\n",
+    "        \"--learning_rate\",\n",
+    "        type=float,\n",
+    "        default=1e-3,\n",
+    "        help=\"Learning rate.\",\n",
+    "    )\n",
+    "    parser.add_argument(\n",
+    "        \"--model_type\",\n",
+    "        type=str,\n",
+    "        default='seam',\n",
+    "        help=\"Type of velocity model used.\",\n",
+    "    )\n",
+    "    parser.add_argument(\n",
+    "        \"--data_type\",\n",
+    "        type=str,\n",
+    "        default='full',\n",
+    "        help=\"Type of data interpolation used.\",\n",
+    "    )\n",
+    "    parser.add_argument(\n",
+    "        \"--middle_shot\",\n",
+    "        type=str,\n",
+    "        default='n',\n",
+    "        help=\"Whether the shots centered at the model (number of shot fixed) or spread accross.\",\n",
+    "    )\n",
+    "    parser.add_argument(\n",
+    "        \"--until_cmb\",\n",
+    "        type=str,\n",
+    "        default='n',\n",
+    "        help=\"Whether the velocity reaches only down to the core-mantle boundary(CMB).\",\n",
+    "    )\n",
+    "    parser.add_argument(\n",
+    "        \"--earth_scale\",\n",
+    "        type=str,\n",
+    "        default='n',\n",
+    "        help=\"Whether the experiment mimics the actual Earth's coordinate values.\",\n",
+    "    )\n",
+    "    parser.add_argument(\n",
+    "        \"--scale_factor\",\n",
+    "        type=int,\n",
+    "        default=10,\n",
+    "        help=\"When the experiments are scaled this corresponds to the factor.\",\n",
+    "    )\n",
+    "    parser.add_argument(\n",
+    "        \"--reduce_after\",\n",
+    "        type=int,\n",
+    "        default=15,\n",
+    "        help=\"When the learning rate should be reduced after stagnancy.\",\n",
+    "    )    \n",
+    "    parser.add_argument(\n",
+    "        \"--seed\",\n",
+    "        type=int,\n",
+    "        default=123,\n",
+    "        help=\"Seed for reproducibility.\",\n",
+    "    ) \n",
+    "    parser.add_argument(\n",
+    "        \"--initialization\",\n",
+    "        type=str,\n",
+    "        default='varianceScaling',\n",
+    "        help=\"Seed for reproducibility.\",\n",
+    "    )\n",
+    "    parser.add_argument(\n",
+    "        \"--plotting_factor\",\n",
+    "        type=int,\n",
+    "        default=1,\n",
+    "        help=\"The multiplication of the coordinate values (default is 1 km x 5 km, vertically and laterally).\",\n",
+    "    )\n",
+    "    parser.add_argument(\n",
+    "        \"--rescale_plot\",\n",
+    "        type=str,\n",
+    "        default='n',\n",
+    "        help=\"Whether the plotting is scaled to mimic the Earth Crust experiment.\",\n",
+    "    )\n",
+    "    parser.add_argument(\n",
+    "        \"--depth_shift\",\n",
+    "        type=str,\n",
+    "        default='n',\n",
+    "        help=\"Whether the plotting is shifted.\",\n",
+    "    )\n",
+    "    parser.add_argument(\n",
+    "        \"--tau_multiplier\",\n",
+    "        type=float,\n",
+    "        default=3.,\n",
+    "        help=\"Scaling factor for the last layer in the tau model.\",\n",
+    "    )\n",
+    "    parser.add_argument(\n",
+    "        \"--initial_velocity\",\n",
+    "        type=float,\n",
+    "        default=4,\n",
+    "        help=\"Starting velocity.\",\n",
+    "    )\n",
+    "    parser.add_argument(\n",
+    "        \"--zid_source\",\n",
+    "        type=int,\n",
+    "        default=5,\n",
+    "        help=\"Z index of the source location.\",\n",
+    "    )\n",
+    "    parser.add_argument(\n",
+    "        \"--zid_receiver\",\n",
+    "        type=int,\n",
+    "        default=0,\n",
+    "        help=\"Z index of the receiver location.\",\n",
+    "    )\n",
+    "    parser.add_argument(\n",
+    "        \"--explode_reflector\",\n",
+    "        type=str,\n",
+    "        default='n',\n",
+    "        help=\"Boolean whether to place the shots in the middle.\",\n",
+    "    )\n",
+    "    parser.add_argument(\n",
+    "        \"--field_synthetic\",\n",
+    "        type=str,\n",
+    "        default='n',\n",
+    "        help=\"Boolean to mimic the field earthquake South California data.\",\n",
+    "    )\n",
+    "    parser.add_argument(\n",
+    "        \"--v_multiplier\",\n",
+    "        type=float,\n",
+    "        default=3,\n",
+    "        help=\"Scaling factor for the last layer in the v model.\",\n",
+    "    )\n",
+    "    parser.add_argument(\n",
+    "        \"--activation\",\n",
+    "        type=str,\n",
+    "        default='elu',\n",
+    "        help=\"Type of activation function.\",\n",
+    "    )\n",
+    "    parser.add_argument(\n",
+    "        \"--num_points\",\n",
+    "        type=float,\n",
+    "        default=1.,\n",
+    "        help=\"Fraction of the collocation points.\",\n",
+    "    )\n",
+    "    parser.add_argument(\n",
+    "        \"--irregular_grid\",\n",
+    "        type=str,\n",
+    "        default='n',\n",
+    "        help=\"Boolean to select random non-regular grid training points.\",\n",
+    "    )\n",
+    "    parser.add_argument(\n",
+    "        \"--xid_well\",\n",
+    "        type=int,\n",
+    "        default=5,\n",
+    "        help=\"Z index of the well location.\",\n",
+    "    )\n",
+    "    parser.add_argument(\n",
+    "        \"--last_vmultiplier\",\n",
+    "        type=int,\n",
+    "        default=5,\n",
+    "        help=\"Integer scalar for the output of the velocity network.\",\n",
+    "    )\n",
+    "    parser.add_argument(\n",
+    "        \"--nu_units\",\n",
+    "        type=str,\n",
+    "        default='unitless',\n",
+    "        help=\"Set whether the velocity network predicts a scalar (unitless) qantity or the velocity field directly.\",\n",
+    "    )\n",
+    "    parser.add_argument(\n",
+    "        \"--well_depth\",\n",
+    "        type=int,\n",
+    "        default=None,\n",
+    "        help=\"Depth index of the end point of the well.\",\n",
+    "    )\n",
+    "    parser.add_argument(\n",
+    "        \"--exp_function\",\n",
+    "        type=str,\n",
+    "        default='n',\n",
+    "        help=\"Imposing smoothness through exponential function.\",\n",
+    "    )\n",
+    "    parser.add_argument(\n",
+    "        \"--exp_factor\",\n",
+    "        type=float,\n",
+    "        default=1.,\n",
+    "        help=\"Imposing smoothness through exponential function; its factor.\",\n",
+    "    )\n",
+    "    parser.add_argument(\n",
+    "        \"--exclude_topo\",\n",
+    "        type=str,\n",
+    "        default='n',\n",
+    "        help=\"Whether the receiver stations locations are not a function of the topopgraphy.\",\n",
+    "    )\n",
+    "    parser.add_argument(\n",
+    "        \"--exclude_well\",\n",
+    "        type=str,\n",
+    "        default='n',\n",
+    "        help=\"Boolean whether to include the well location for training.\",\n",
+    "    )\n",
+    "    parser.add_argument(\n",
+    "        \"--exclude_source\",\n",
+    "        type=str,\n",
+    "        default='n',\n",
+    "        help=\"Boolean whether to include the source location for training.\",\n",
+    "    )\n",
+    "    parser.add_argument(\n",
+    "        \"--loss_function\",\n",
+    "        type=str,\n",
+    "        default='mse',\n",
+    "        help=\"Type of metric for the regression loss.\",\n",
+    "    )\n",
+    "    parser.add_argument(\n",
+    "        \"--station_factor\",\n",
+    "        type=float,\n",
+    "        default=1.,\n",
+    "        help=\"Scale the real earthquake depth for semi-synhtetic experiments.\",\n",
+    "    )\n",
+    "    parser.add_argument(\n",
+    "        \"--event_factor\",\n",
+    "        type=float,\n",
+    "        default=1.,\n",
+    "        help=\"Scale the real earthquake depth for semi-synhtetic experiments.\",\n",
+    "    )\n",
+    "    parser.add_argument(\n",
+    "        \"--checker_size\",\n",
+    "        type=float,\n",
+    "        default=5.,\n",
+    "        help=\"Scale the real earthquake depth for semi-synhtetic experiments.\",\n",
+    "    )\n",
+    "    parser.add_argument(\n",
+    "        \"--tau_act\",\n",
+    "        type=str,\n",
+    "        default='None',\n",
+    "        help=\"Last activation function for the tau model.\",\n",
+    "    )\n",
+    "    parser.add_argument(\n",
+    "        \"--empty_middle\",\n",
+    "        type=str,\n",
+    "        default='n',\n",
+    "        help=\"Imposing no recording nor shot in the middle part of the model.\",\n",
+    "    )\n",
+    "    parser.add_argument(\n",
+    "        \"--factorization_type\",\n",
+    "        type=str,\n",
+    "        default='multiplicative',\n",
+    "        help=\"Types of factorization used for the eikonal.\",\n",
+    "    )\n",
+    "    parser.add_argument(\n",
+    "        \"--causality_factor\",\n",
+    "        type=float,\n",
+    "        default=1.,\n",
+    "        help=\"Exponential coefficient from the original CausalPINNs paper.\",\n",
+    "    )\n",
+    "    parser.add_argument(\n",
+    "        \"--causality_weight\",\n",
+    "        type=str,\n",
+    "        default='type_0',\n",
+    "        help=\"Exponential coefficient from the original CausalPINNs paper.\",\n",
+    "    )\n",
+    "    parser.add_argument(\n",
+    "        \"--residual_network\",\n",
+    "        type=str,\n",
+    "        default='n',\n",
+    "        help=\"Whether a network with residual connections is used.\",\n",
+    "    )\n",
+    "    parser.add_argument(\n",
+    "        \"--velocity_loss\",\n",
+    "        type=str,\n",
+    "        default='n',\n",
+    "        help=\"Whether the loss uses a velocity unit.\",\n",
+    "    )\n",
+    "    parser.add_argument(\n",
+    "        \"--regular_station\",\n",
+    "        type=str,\n",
+    "        default='n',\n",
+    "        help=\"Whether the station for the field is regularly sampled.\",\n",
+    "    )\n",
+    "    parser.add_argument(\n",
+    "        \"--data_neurons\",\n",
+    "        type=int,\n",
+    "        default=16,\n",
+    "        help=\"Neurons width.\",\n",
+    "    )\n",
+    "    parser.add_argument(\n",
+    "        \"--data_layers\",\n",
+    "        type=int,\n",
+    "        default=8,\n",
+    "        help=\"Layers depth.\",\n",
+    "    )\n",
+    "    parser.add_argument(\n",
+    "        \"--append_shot\",\n",
+    "        type=str,\n",
+    "        default='n',\n",
+    "        help=\"Whether we add virtual shot at the bottom right of the model.\",\n",
+    "    )\n",
+    "    args = parser.parse_args([])\n",
+    "    dict_args = vars(args)\n",
+    "    print(dict_args)"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 27,
+   "id": "a2c6fc60-cac1-4243-a81e-da4d4d5f23d6",
+   "metadata": {},
+   "outputs": [
+    {
+     "name": "stdout",
+     "output_type": "stream",
+     "text": [
+      "{'lateral_spacing': 0.03, 'vertical_spacing': 0.01, 'max_offset': 8.6, 'max_depth': 1, 'rec_spacing': 20, 'sou_spacing': 40, 'num_epochs': 3000, 'num_neurons': 24, 'num_layers': 12, 'learning_rate': 0.001, 'model_type': 'marmousi', 'data_type': 'nn', 'middle_shot': 'n', 'until_cmb': 'y', 'earth_scale': 'n', 'scale_factor': 2, 'reduce_after': 50, 'seed': 1234, 'initialization': 'varianceScaling', 'plotting_factor': 1, 'rescale_plot': 'y', 'depth_shift': 'n', 'tau_multiplier': 1, 'initial_velocity': 3, 'zid_source': 5, 'zid_receiver': 0, 'explode_reflector': 'n', 'field_synthetic': 'y', 'v_multiplier': 3, 'activation': 'elu', 'num_points': 1.0, 'irregular_grid': 'y', 'xid_well': 5, 'last_vmultiplier': 5, 'nu_units': 'unitless', 'well_depth': None, 'exp_function': 'n', 'exp_factor': 1.0, 'exclude_topo': 'n', 'exclude_well': 'n', 'exclude_source': 'n', 'loss_function': 'mse', 'station_factor': 0.1, 'event_factor': 0.9, 'checker_size': 5.0, 'tau_act': 'tanh', 'empty_middle': 'n', 'factorization_type': 'additive', 'causality_factor': 0.5, 'causality_weight': 'type_0', 'residual_network': 'y', 'velocity_loss': 'n', 'regular_station': 'y', 'data_neurons': 16, 'data_layers': 8, 'append_shot': 'n'}\n"
+     ]
+    }
+   ],
+   "source": [
+    "args.scale_factor=2 \n",
+    "args.until_cmb='y' \n",
+    "args.num_epochs=3000 \n",
+    "args.seed=1234 \n",
+    "args.learning_rate=1e-3 \n",
+    "args.rescale_plot='y' \n",
+    "args.initial_velocity=3 \n",
+    "args.zid_source=5 \n",
+    "args.zid_receiver=0 \n",
+    "args.data_type='nn' \n",
+    "args.irregular_grid='y' \n",
+    "args.num_layers=12 \n",
+    "args.model_type='marmousi' \n",
+    "args.v_multiplier=3 \n",
+    "args.factorization_type='additive' \n",
+    "args.tau_act='tanh' \n",
+    "args.tau_multiplier=1 \n",
+    "args.max_offset=8.6 \n",
+    "args.max_depth=1 \n",
+    "args.vertical_spacing=0.01 \n",
+    "args.lateral_spacing=0.03 \n",
+    "args.num_neurons=24 \n",
+    "args.causality_factor=.5 \n",
+    "\n",
+    "args.causality_weight='type_0' \n",
+    "args.reduce_after=50 \n",
+    "args.field_synthetic='y' \n",
+    "args.event_factor=0.9 \n",
+    "args.station_factor=0.1 \n",
+    "args.residual_network='y' \n",
+    "args.empty_middle='n' \n",
+    "args.regular_station='y' \n",
+    "args.rec_spacing=20 \n",
+    "args.sou_spacing=40\n",
+    "\n",
+    "dict_args = vars(args)\n",
+    "print(dict_args)"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 28,
+   "id": "8a49dd75-33c0-4616-a997-72e405a3f7cd",
+   "metadata": {},
+   "outputs": [
+    {
+     "name": "stdout",
+     "output_type": "stream",
+     "text": [
+      "Cuda installed! Running on GPU!\n",
+      "Device: cuda:0 Quadro RTX 8000\n"
+     ]
+    },
+    {
+     "name": "stderr",
+     "output_type": "stream",
+     "text": [
+      "/tmp/ipykernel_23937/481285251.py:71: SettingWithCopyWarning: \n",
+      "A value is trying to be set on a copy of a slice from a DataFrame.\n",
+      "Try using .loc[row_indexer,col_indexer] = value instead\n",
+      "\n",
+      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",
+      "  eve_only.loc[:, 'closest_event'] = np.copy(d[0].values)\n",
+      "/tmp/ipykernel_23937/481285251.py:79: SettingWithCopyWarning: \n",
+      "A value is trying to be set on a copy of a slice from a DataFrame.\n",
+      "Try using .loc[row_indexer,col_indexer] = value instead\n",
+      "\n",
+      "See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n",
+      "  sta_only.loc[:, 'closest_station'] = np.copy(d[0].values)\n",
+      "pygmt-session [WARNING]: Remote dataset given to a data processing module but no registration was specified - default to gridline registration (if available)\n"
+     ]
+    },
+    {
+     "name": "stdout",
+     "output_type": "stream",
+     "text": [
+      "4.551132167026825 15 15 29 29\n"
+     ]
+    },
+    {
+     "ename": "NameError",
+     "evalue": "name 'xmin' is not defined",
+     "output_type": "error",
+     "traceback": [
+      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
+      "\u001b[0;31mNameError\u001b[0m                                 Traceback (most recent call last)",
+      "Cell \u001b[0;32mIn[28], line 236\u001b[0m\n\u001b[1;32m    233\u001b[0m velmodel \u001b[38;5;241m=\u001b[39m np\u001b[38;5;241m.\u001b[39mrepeat(vel[\u001b[38;5;241m.\u001b[39m\u001b[38;5;241m.\u001b[39m\u001b[38;5;241m.\u001b[39m,np\u001b[38;5;241m.\u001b[39mnewaxis],sx\u001b[38;5;241m.\u001b[39msize,axis\u001b[38;5;241m=\u001b[39m\u001b[38;5;241m2\u001b[39m)\n\u001b[1;32m    235\u001b[0m \u001b[38;5;28mprint\u001b[39m(np\u001b[38;5;241m.\u001b[39mnanmax(velmodel), \u001b[38;5;28mlen\u001b[39m(id_rec_z), \u001b[38;5;28mlen\u001b[39m(id_rec_x), \u001b[38;5;28mlen\u001b[39m(id_sou_z), \u001b[38;5;28mlen\u001b[39m(id_sou_x))\n\u001b[0;32m--> 236\u001b[0m \u001b[43mplot_section\u001b[49m\u001b[43m(\u001b[49m\u001b[43mvelmodel\u001b[49m\u001b[43m[\u001b[49m\u001b[43m:\u001b[49m\u001b[43m,\u001b[49m\u001b[43m:\u001b[49m\u001b[43m,\u001b[49m\u001b[38;5;241;43m0\u001b[39;49m\u001b[43m]\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[38;5;124;43m'\u001b[39;49m\u001b[38;5;124;43mv_true.png\u001b[39;49m\u001b[38;5;124;43m'\u001b[39;49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mvmin\u001b[49m\u001b[38;5;241;43m=\u001b[39;49m\u001b[43mnp\u001b[49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43mnanmin\u001b[49m\u001b[43m(\u001b[49m\u001b[43mvelmodel\u001b[49m\u001b[43m)\u001b[49m\u001b[38;5;241;43m+\u001b[39;49m\u001b[38;5;241;43m0.1\u001b[39;49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mvmax\u001b[49m\u001b[38;5;241;43m=\u001b[39;49m\u001b[43mnp\u001b[49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43mnanmax\u001b[49m\u001b[43m(\u001b[49m\u001b[43mvelmodel\u001b[49m\u001b[43m)\u001b[49m\u001b[38;5;241;43m-\u001b[39;49m\u001b[38;5;241;43m0.5\u001b[39;49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43msave_dir\u001b[49m\u001b[38;5;241;43m=\u001b[39;49m\u001b[43mwandb\u001b[49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43mrun\u001b[49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43mdir\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43maspect\u001b[49m\u001b[38;5;241;43m=\u001b[39;49m\u001b[38;5;124;43m'\u001b[39;49m\u001b[38;5;124;43mequal\u001b[39;49m\u001b[38;5;124;43m'\u001b[39;49m\u001b[43m)\u001b[49m\n\u001b[1;32m    238\u001b[0m \u001b[38;5;28;01mif\u001b[39;00m args\u001b[38;5;241m.\u001b[39mdepth_shift\u001b[38;5;241m==\u001b[39m\u001b[38;5;124m'\u001b[39m\u001b[38;5;124my\u001b[39m\u001b[38;5;124m'\u001b[39m:\n\u001b[1;32m    239\u001b[0m     zmin, zmax, z, sz, Z, SZ \u001b[38;5;241m=\u001b[39m zmin\u001b[38;5;241m+\u001b[39m\u001b[38;5;241m5\u001b[39m, zmax\u001b[38;5;241m+\u001b[39m\u001b[38;5;241m5\u001b[39m, z\u001b[38;5;241m+\u001b[39m\u001b[38;5;241m5\u001b[39m, sz\u001b[38;5;241m+\u001b[39m\u001b[38;5;241m5\u001b[39m, Z\u001b[38;5;241m+\u001b[39m\u001b[38;5;241m5\u001b[39m, SZ\u001b[38;5;241m+\u001b[39m\u001b[38;5;241m5\u001b[39m\n",
+      "File \u001b[0;32m~/my_paper/eage2023_paper1/repo/HCPINNsEikonal-dev/src/hcpinnseikonal/plot.py:42\u001b[0m, in \u001b[0;36mplot_section\u001b[0;34m(data, fig_name, data_type, vmin, vmax, cmap, save_dir, aspect)\u001b[0m\n\u001b[1;32m     40\u001b[0m plt\u001b[38;5;241m.\u001b[39mfigure()\n\u001b[1;32m     41\u001b[0m ax \u001b[38;5;241m=\u001b[39m plt\u001b[38;5;241m.\u001b[39mgca()\n\u001b[0;32m---> 42\u001b[0m im \u001b[38;5;241m=\u001b[39m ax\u001b[38;5;241m.\u001b[39mimshow(data, extent\u001b[38;5;241m=\u001b[39m[\u001b[43mxmin\u001b[49m,xmax,zmax,zmin], cmap\u001b[38;5;241m=\u001b[39mcmap, \n\u001b[1;32m     43\u001b[0m                aspect\u001b[38;5;241m=\u001b[39maspect, vmin\u001b[38;5;241m=\u001b[39mvmin, vmax\u001b[38;5;241m=\u001b[39mvmax, interpolation\u001b[38;5;241m=\u001b[39m\u001b[38;5;124m'\u001b[39m\u001b[38;5;124mkaiser\u001b[39m\u001b[38;5;124m'\u001b[39m)\n\u001b[1;32m     45\u001b[0m \u001b[38;5;28;01mif\u001b[39;00m id_sou_z\u001b[38;5;241m.\u001b[39msize\u001b[38;5;241m>\u001b[39m\u001b[38;5;241m1\u001b[39m:\n\u001b[1;32m     46\u001b[0m     plt\u001b[38;5;241m.\u001b[39mscatter(x[id_sou_x], z[id_sou_z], \u001b[38;5;241m5\u001b[39m, \u001b[38;5;124m'\u001b[39m\u001b[38;5;124mwhite\u001b[39m\u001b[38;5;124m'\u001b[39m, marker\u001b[38;5;241m=\u001b[39m\u001b[38;5;124m'\u001b[39m\u001b[38;5;124m*\u001b[39m\u001b[38;5;124m'\u001b[39m)\n",
+      "\u001b[0;31mNameError\u001b[0m: name 'xmin' is not defined"
+     ]
+    },
+    {
+     "data": {
+      "image/png": "iVBORw0KGgoAAAANSUhEUgAAAjcAAAHFCAYAAAAOmtghAAAAOXRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjYuMSwgaHR0cHM6Ly9tYXRwbG90bGliLm9yZy/av/WaAAAACXBIWXMAAA9hAAAPYQGoP6dpAABMrUlEQVR4nO3deXhTZd4+8Ptk7xro3kJbCoJQytZ2cABR2Ret4qsCzquggziAG3TGUQZetp/SEUfFjYoi6ggio4MiAwJVkEXKsCNYRIFCWVpKW0i6JW2S8/ujNDR0S9u0Jzm5P9eVC3pyTvKcFsjNs3wfQRRFEUREREQyoZC6AURERESuxHBDREREssJwQ0RERLLCcENERESywnBDREREssJwQ0RERLLCcENERESywnBDREREssJwQ0RERLLCcEPk5X766Sc8/vjjiIuLg06ng7+/PxITE7FkyRIUFRVJ3Ty3tGfPHixYsADXrl2r9dxdd92Fu+66q83bREQ3CNx+gch7ffDBB5gxYwZuvfVWzJgxA/Hx8aisrMSBAwfwwQcfoE+fPvjqq6+kbqbb+cc//oHnn38e2dnZ6NSpk8NzWVlZAID4+HgJWkZEAKCSugFEJI3MzExMnz4dI0aMwNdffw2tVmt/bsSIEfjzn/+MzZs313t9eXk5fHx82qKpHoWhhkh6HJYi8lKLFy+GIAh4//33HYJNNY1Gg3vvvRcA0KlTJ9xzzz1Yt24d+vXrB51Oh4ULFwIAjh8/jvvuuw/t27eHTqdD37598cknnzi8ls1mw0svvYRbb70VPj4+aNeuHXr37o0333zTfs6VK1fw5JNPIjo6GlqtFqGhoRg0aBC+++67Ru/lzJkzmDhxIqKioqDVahEeHo5hw4bhyJEjDuetXbsWAwYMgJ+fH/z9/TFq1CgcPny41uv997//RUpKCoKDg6HT6dClSxfMnDkTALBgwQI8//zzAIC4uDgIggBBEPDDDz8AqHtYqqioCDNmzECHDh2g0WjQuXNnzJkzB2az2eE8QRDw9NNP49NPP0WPHj3g6+uLPn364D//+U+j3wMiuoE9N0ReyGq1Ytu2bUhKSkJ0dLRT1xw6dAgnTpzA3LlzERcXBz8/P5w8eRIDBw5EWFgY3nrrLQQHB2PVqlV47LHHcPnyZfz1r38FACxZsgQLFizA3Llzcccdd6CyshK//PKLw5yVRx99FIcOHcLLL7+Mbt264dq1azh06BAKCwsbbdvYsWNhtVqxZMkSxMTEoKCgAHv27HF4/cWLF2Pu3Ll4/PHHMXfuXFRUVODVV1/F4MGDsW/fPnuPy5YtW5CSkoIePXrg9ddfR0xMDM6ePYutW7cCAJ544gkUFRXh7bffxrp16xAZGQmg/h4bk8mEIUOG4PTp01i4cCF69+6NXbt2IS0tDUeOHMHGjRsdzt+4cSP279+PRYsWwd/fH0uWLMH999+PkydPonPnzk79rIi8nkhEXicvL08EIE6cONGp82NjY0WlUimePHnS4fjEiRNFrVYr5uTkOBwfM2aM6OvrK167dk0URVG85557xL59+zb4Hv7+/uLMmTObcBdVCgoKRADi0qVL6z0nJydHVKlU4jPPPONwvLi4WIyIiBDHjx9vP9alSxexS5cuYnl5eb2v9+qrr4oAxOzs7FrP3XnnneKdd95p//q9994TAYj/+te/HM575ZVXRADi1q1b7ccAiOHh4aLRaLQfy8vLExUKhZiWllZve4jIEYeliMgpvXv3Rrdu3RyObdu2DcOGDavV+/PYY4+hrKwMmZmZAID+/fvj6NGjmDFjBrZs2QKj0Vjr9fv374+PP/4YL730Evbu3YvKykqH50VRhMVicXgAQFBQELp06YJXX30Vr7/+Og4fPgybzeZw7ZYtW2CxWDBp0iSH63U6He688077kNKvv/6K06dPY8qUKdDpdC36ftX8Hvn5+eHBBx+s9T0CgO+//97h+JAhQxAQEGD/Ojw8HGFhYTh37pxL2kPkDRhuiLxQSEgIfH19kZ2d7fQ11cMvNRUWFtZ5PCoqyv48AMyePRv/+Mc/sHfvXowZMwbBwcEYNmwYDhw4YL9m7dq1mDx5MlasWIEBAwYgKCgIkyZNQl5eHgDgk08+gVqtdngAVfNUvv/+e4waNQpLlixBYmIiQkND8eyzz6K4uBgAcPnyZQDA7373u1qvsXbtWhQUFAComvcDAB07dnT6+9KYwsJCREREQBAEh+NhYWFQqVS1ht2Cg4NrvYZWq0V5ebnL2kQkd5xzQ+SFlEolhg0bhm+//RYXLlxw6sP85g9noOqDODc3t9bxS5cuAagKUQCgUqmQmpqK1NRUXLt2Dd999x3+9re/YdSoUTh//jx8fX0REhKCpUuXYunSpcjJycE333yDF198Efn5+di8eTNSUlKwf//+OtsWGxuLDz/8EEBV78u//vUvLFiwABUVFXjvvffs7fjyyy8RGxtb7z2GhoYCAC5cuNDo98NZwcHB+O9//wtRFB2+h/n5+bBYLPa2EZHrsOeGyEvNnj0boihi6tSpqKioqPV8ZWUlNmzY0OBrDBs2DNu2bbOHmWr//Oc/4evri9///ve1rmnXrh0efPBBPPXUUygqKsLZs2drnRMTE4Onn34aI0aMwKFDhwBUhYTk5GSHR126deuGuXPnolevXvZrR40aBZVKhdOnT9d6jZqv1a1bN3Tp0gUrV66stZKppurVZc70pgwbNgwlJSX4+uuva32Pqp8nItdizw2RlxowYADS09MxY8YMJCUlYfr06ejZsycqKytx+PBhvP/++0hISEBKSkq9rzF//nz85z//wZAhQzBv3jwEBQVh9erV2LhxI5YsWQK9Xg8ASElJQUJCApKTkxEaGopz585h6dKliI2NRdeuXWEwGDBkyBD84Q9/QPfu3REQEID9+/dj8+bN+J//+Z8G7+Onn37C008/jYceeghdu3aFRqPBtm3b8NNPP+HFF18EULWUfdGiRZgzZw7OnDmD0aNHo3379rh8+TL27dsHPz8/+9L2d999FykpKfj973+PWbNmISYmBjk5OdiyZQtWr14NAOjVqxcA4M0338TkyZOhVqtx6623OsyVqTZp0iS8++67mDx5Ms6ePYtevXph9+7dWLx4McaOHYvhw4c3/YdHRA2TeEIzEUnsyJEj4uTJk8WYmBhRo9GIfn5+Yr9+/cR58+aJ+fn5oihWrZa6++6767z+2LFjYkpKiqjX60WNRiP26dNH/OijjxzOee2118SBAweKISEhokajEWNiYsQpU6aIZ8+eFUVRFE0mkzht2jSxd+/eYmBgoOjj4yPeeuut4vz588XS0tIG23/58mXxscceE7t37y76+fmJ/v7+Yu/evcU33nhDtFgsDud+/fXX4pAhQ8TAwEBRq9WKsbGx4oMPPih+9913DudlZmaKY8aMEfV6vajVasUuXbqIs2bNcjhn9uzZYlRUlKhQKEQA4vbt20VRrL1aShRFsbCwUJw2bZoYGRkpqlQqMTY2Vpw9e7ZoMpkczgMgPvXUU7XuMTY2Vpw8eXKD3wciuoHbLxAREZGscM4NERERyQrDDREREckKww0RERHJCsMN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\n",
+      "text/plain": [
+       "<Figure size 640x480 with 1 Axes>"
+      ]
+     },
+     "metadata": {},
+     "output_type": "display_data"
+    },
+    {
+     "data": {
+      "image/png": "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\n",
+      "text/plain": [
+       "<Figure size 640x480 with 1 Axes>"
+      ]
+     },
+     "metadata": {},
+     "output_type": "display_data"
+    }
+   ],
+   "source": [
+    "# Setup\n",
+    "wandb.config.update(args)\n",
+    "\n",
+    "seed = args.seed\n",
+    "\n",
+    "set_seed(seed)\n",
+    "device = set_device()\n",
+    "\n",
+    "# Medium\n",
+    "data_type = args.data_type\n",
+    "deltar = args.rec_spacing\n",
+    "deltas = args.sou_spacing\n",
+    "\n",
+    "# Computational model parameters\n",
+    "zmin = -0.1 if args.field_synthetic=='y' else 0; zmax = args.max_depth; deltaz = args.vertical_spacing;\n",
+    "xmin = 0.; xmax = args.max_offset; deltax = args.lateral_spacing;\n",
+    "\n",
+    "if args.earth_scale=='y':\n",
+    "    earth_radi = 6371/args.scale_factor # Average in km\n",
+    "    xmin, xmax, deltax = earth_radi*xmin, earth_radi*xmax, earth_radi*deltax\n",
+    "    zmin, zmax, deltaz = earth_radi*zmin, earth_radi*zmax, earth_radi*deltaz\n",
+    "\n",
+    "# Creating grid, extending the velocity model, and prepare list of grid points for training (X_star)\n",
+    "z = np.arange(zmin,zmax+deltaz,deltaz)\n",
+    "nz = z.size\n",
+    "\n",
+    "x = np.arange(xmin,xmax+deltax,deltax)\n",
+    "nx = x.size\n",
+    "\n",
+    "# Number of training points\n",
+    "num_tr_pts = 4000 #int(args.num_points * nz * nx)\n",
+    "\n",
+    "if args.field_synthetic=='y':\n",
+    "    import pandas as pd\n",
+    "    import pygmt\n",
+    "    import numpy as np\n",
+    "\n",
+    "    import pandas as pd\n",
+    "\n",
+    "    # Earthquake events location\n",
+    "    location = pd.read_csv('/home/taufikmh/KAUST/fall_2022/GFATT_PINNs/data/fang_etal_2020/sjfzcatlog.csv')\n",
+    "\n",
+    "    # Recorded traveltime data\n",
+    "    traveltime = pd.read_table('/home/taufikmh/KAUST/fall_2022/GFATT_PINNs/data/fang_etal_2020/sjfz_traveltime.dat', delim_whitespace='y')\n",
+    "\n",
+    "    # Rounding to make the coordinates rounding the same\n",
+    "    location, traveltime = location.round(3), traveltime.round(3)\n",
+    "\n",
+    "    # Merge\n",
+    "    data = pd.merge(traveltime, location,  how='left', left_on=['evlat','evlon','evdep'], right_on = ['evlat','evlon','evdep'])\n",
+    "\n",
+    "    # Create earthquake group\n",
+    "    data['event_id'] = data.groupby(['evlat', 'evlon', 'evdep']).cumcount() + 1\n",
+    "    data['station_id'] = data.groupby(['stlat', 'stlon', 'stele']).cumcount() + 1\n",
+    "\n",
+    "    # Station only\n",
+    "    sta_only = data.drop_duplicates(subset=['stlat', 'stlon'], keep='last')\n",
+    "\n",
+    "    # Event only\n",
+    "    eve_only = data.drop_duplicates(subset=['evlat', 'evlon'], keep='last')\n",
+    "\n",
+    "    region = [-118, -115, 32.5, 34.50]\n",
+    "    x0,x1,y0,y1 = -117.45, -115.55, 34.15, 32.76\n",
+    "\n",
+    "    # eve_only['dist_to_line'] = \n",
+    "    p1=np.array([(360+x0)*np.ones_like(eve_only.event_id.values), y0*np.ones_like(eve_only.event_id.values)])\n",
+    "    p2=np.array([(360+x1)*np.ones_like(eve_only.event_id.values), y1*np.ones_like(eve_only.event_id.values)])\n",
+    "    p3=np.array([eve_only.evlon, eve_only.evlat])\n",
+    "\n",
+    "    d = pd.DataFrame(np.cross((p2-p1).T,(p3-p1).T)/np.linalg.norm((p2-p1).T))\n",
+    "    eve_only.loc[:, 'closest_event'] = np.copy(d[0].values)\n",
+    "\n",
+    "    # sta_only['dist_to_line'] = \n",
+    "    p1=np.array([(360+x0)*np.ones_like(sta_only.station_id.values), y0*np.ones_like(sta_only.station_id.values)])\n",
+    "    p2=np.array([(360+x1)*np.ones_like(sta_only.station_id.values), y1*np.ones_like(sta_only.station_id.values)])\n",
+    "    p3=np.array([sta_only.stlon, sta_only.stlat])\n",
+    "\n",
+    "    d = pd.DataFrame(np.cross((p2-p1).T,(p3-p1).T)/np.linalg.norm((p2-p1).T))\n",
+    "    sta_only.loc[:, 'closest_station'] = np.copy(d[0].values)\n",
+    "\n",
+    "    closest_sta = sta_only[np.abs(sta_only['closest_station'])<0.003]\n",
+    "    closest_eve = eve_only[np.abs(eve_only['closest_event'])<0.00003]\n",
+    "\n",
+    "    grid = pygmt.datasets.load_earth_relief(resolution=\"03m\", region=region)\n",
+    "\n",
+    "    points = pd.DataFrame(\n",
+    "        data=np.linspace(start=(x0, y0), stop=(x1, y1), num=len(x)),\n",
+    "        columns=[\"x\", \"y\"],\n",
+    "    )\n",
+    "\n",
+    "    track = pygmt.grdtrack(points=points, grid=grid, newcolname=\"elevation\")\n",
+    "    xtop = track.x.values + 360\n",
+    "    ztop = track.elevation.values*1e-3\n",
+    "\n",
+    "    xsta = closest_sta.stlon.values\n",
+    "    zsta = closest_sta.stele.values\n",
+    "\n",
+    "    xeve = closest_eve.evlon.values\n",
+    "    zeve = closest_eve.evdep.values\n",
+    "\n",
+    "    xtop,xsta,xeve = xtop-xtop.min(),xsta-xsta.min(),xeve-xeve.min()\n",
+    "    xtop,xsta,xeve = xtop/xtop.max()*xmax,xsta/xsta.max()*xmax,xeve/xeve.max()*xmax\n",
+    "\n",
+    "    ztop,zsta,zeve = ztop-ztop.min(),zsta-zsta.min(),zeve-zeve.min()\n",
+    "    ztop,zsta,zeve = args.station_factor*ztop/ztop.max()+zmin,args.station_factor*zsta/zsta.max()+zmin,zmax-args.event_factor*zeve/zeve.max()\n",
+    "\n",
+    "    xsta,xeve,zsta,zeve = xsta[(xsta>xtop.min()) & (xsta<xtop.max())],xeve[(xeve>xtop.min()) & (xeve<xtop.max())],zsta[(xsta>xtop.min()) & (xsta<xtop.max())],zeve[(xeve>xtop.min()) & (xeve<xtop.max())]\n",
+    "\n",
+    "    if args.exclude_topo=='y':\n",
+    "        ztop, zsta = zmin*np.ones_like(ztop), zmin*np.ones_like(zsta)\n",
+    "\n",
+    "    ztop, zsta = zmin-ztop, zmin-zsta\n",
+    "\n",
+    "    id_sou_z = np.array([]).astype(int)\n",
+    "\n",
+    "    for szi in zeve.round(2):\n",
+    "        sid = np.where(np.abs(z.round(3)-szi)<1e-6)\n",
+    "        id_sou_z = np.append(id_sou_z,sid)\n",
+    "\n",
+    "    id_rec_z = np.array([]).astype(int)\n",
+    "\n",
+    "    for rzi in zsta.round(2):\n",
+    "        sid = np.where(np.abs(z.round(3)-rzi)<1e-6)\n",
+    "        id_rec_z = np.append(id_rec_z,sid)\n",
+    "\n",
+    "    id_sou_x = np.array([]).astype(int)\n",
+    "\n",
+    "    for sxi in xeve.round(2):\n",
+    "        sid = np.where(np.abs(x.round(3)-sxi)<1.5e-2)\n",
+    "        id_sou_x = np.append(id_sou_x,sid)\n",
+    "\n",
+    "    id_rec_x = np.array([]).astype(int)\n",
+    "\n",
+    "    for rxi in xsta.round(2):\n",
+    "        sid = np.where(np.abs(x.round(3)-rxi)<1.5e-2)\n",
+    "        id_rec_x = np.append(id_rec_x,sid)\n",
+    "\n",
+    "    id_top_x = []\n",
+    "    id_top_z = []\n",
+    "\n",
+    "    for h in range(len(xtop)):\n",
+    "\n",
+    "        for i in range(len(x)):\n",
+    "            if np.abs(xtop[h]-x[i])<1e-2:\n",
+    "                id_top_x.append(i)\n",
+    "\n",
+    "        for j in range(len(z)):    \n",
+    "            if np.abs(ztop[h]-z[j])<5e-3:\n",
+    "                id_top_z.append(j)\n",
+    "\n",
+    "    if args.regular_station=='y':\n",
+    "        id_rec_x = id_top_x[::args.rec_spacing]\n",
+    "        id_rec_z = id_top_z[::args.rec_spacing]\n",
+    "\n",
+    "    if args.append_shot=='y':\n",
+    "        for i in range(8):\n",
+    "            id_sou_x = np.append(id_sou_x, len(x)-1-2*i)\n",
+    "            id_sou_z = np.append(id_sou_z, len(z)-1-int(0.5*i))\n",
+    "            \n",
+    "    plt.plot(args.plotting_factor*(xtop-xtop.min()), args.plotting_factor*ztop)\n",
+    "    plt.scatter(args.plotting_factor*(xeve-xtop.min()), args.plotting_factor*zeve)\n",
+    "    plt.scatter(x[id_rec_x], z[id_rec_z], c='y', marker='v')\n",
+    "    plt.title('Cross-section')\n",
+    "    plt.xlabel('X (km)')\n",
+    "    plt.ylabel('Z (km)')\n",
+    "    plt.gca().invert_yaxis()\n",
+    "    plt.axis('tight')\n",
+    "    plt.savefig(os.path.join(wandb.run.dir, 'cross_section.png'), format='png', bbox_inches=\"tight\")\n",
+    "else:\n",
+    "    zeve, xeve = z[args.zid_source]*np.ones_like(x[id_sou_x]), x[id_sou_x]\n",
+    "    zsta, xsta = z[args.zid_receiver]*np.ones_like(x[id_rec_x]), x[id_rec_x]\n",
+    "    ztop, xtop = zmin*np.ones_like(x), np.copy(x)\n",
+    "\n",
+    "    id_sou_z = np.array([]).astype(int)\n",
+    "\n",
+    "    for szi in zeve.round(2):\n",
+    "        sid = np.where(np.abs(z.round(3)-szi)<1e-6)\n",
+    "        id_sou_z = np.append(id_sou_z,sid)\n",
+    "\n",
+    "    id_sou_x = np.array([]).astype(int)\n",
+    "\n",
+    "    for sxi in xeve.round(2):\n",
+    "        sid = np.where(np.abs(x.round(3)-sxi)<1e-6)\n",
+    "        id_sou_x = np.append(id_sou_x,sid)\n",
+    "\n",
+    "    id_rec_z = np.array([]).astype(int)\n",
+    "\n",
+    "    for szi in zsta.round(2):\n",
+    "        sid = np.where(np.abs(z.round(3)-szi)<1e-6)\n",
+    "        id_rec_z = np.append(id_rec_z,sid)\n",
+    "\n",
+    "    id_rec_x = np.array([]).astype(int)\n",
+    "\n",
+    "    for sxi in xsta.round(2):\n",
+    "        sid = np.where(np.abs(x.round(3)-sxi)<1e-6)\n",
+    "        id_rec_x = np.append(id_rec_x,sid)\n",
+    "\n",
+    "# Keeping the number of shots fixed while centering the shots location\n",
+    "if args.middle_shot=='y':\n",
+    "    id_sou_left = x.shape[0]//2-len(id_sou_x)//2\n",
+    "    id_sou_x = np.array(range(id_sou_left, id_sou_left+len(id_sou_x)))\n",
+    "\n",
+    "if args.explode_reflector=='y':\n",
+    "    id_sou_x = np.arange(0, len(x), args.sou_spacing)\n",
+    "    id_sou_z = np.ones_like(id_sou_x)*(len(z)-1)\n",
+    "\n",
+    "if args.empty_middle=='y':\n",
+    "    id_sou, id_rec = (np.array(id_sou_x)<=(len(x)//2-50))|(np.array(id_sou_x)>=(len(x)//2+50)), (np.array(id_rec_x)<=(len(x)//2-50))|(np.array(id_rec_x)>=(len(x)//2+50))\n",
+    "    if args.field_synthetic=='n':\n",
+    "        id_sou_x = np.array(id_sou_x)[id_sou]\n",
+    "        id_sou_z = np.array(id_sou_z)[id_sou]\n",
+    "    id_rec_x = np.array(id_rec_x)[id_rec]\n",
+    "    id_rec_z = np.array(id_rec_z)[id_rec]\n",
+    "\n",
+    "sz = z[id_sou_z]\n",
+    "sx = x[id_sou_x]\n",
+    "\n",
+    "Z,X,SX = np.meshgrid(z,x,sx,indexing='ij')\n",
+    "\n",
+    "SZ = np.ones(SX.shape)*sz # Creating an array of sources along z with same size as SX\n",
+    "\n",
+    "\n",
+    "vel = np.fromfile('../data/marmousi.bin', np.float32).reshape(221, 601)\n",
+    "x1 = np.linspace(0, 5, 601)\n",
+    "z1 = np.linspace(0, 1, 221) \n",
+    "from scipy import interpolate\n",
+    "x2 = np.linspace(0.25, 5, len(x))\n",
+    "z2 = np.linspace(0.09, 0.55, len(z)) \n",
+    "f = interpolate.interp2d(x1, z1, vel, kind='cubic')\n",
+    "vel = f(x2, z2)\n",
+    "\n",
+    "# Extending the velocity model in thirs dimension byy repeatin the array\n",
+    "velmodel = np.repeat(vel[...,np.newaxis],sx.size,axis=2)\n",
+    "\n",
+    "print(np.nanmax(velmodel), len(id_rec_z), len(id_rec_x), len(id_sou_z), len(id_sou_x))\n",
+    "plot_section(velmodel[:,:,0], 'v_true.png', vmin=np.nanmin(velmodel)+0.1, vmax=np.nanmax(velmodel)-0.5, save_dir=wandb.run.dir, aspect='equal')\n",
+    "\n",
+    "if args.depth_shift=='y':\n",
+    "    zmin, zmax, z, sz, Z, SZ = zmin+5, zmax+5, z+5, sz+5, Z+5, SZ+5\n",
+    "\n",
+    "X_star = [Z.reshape(-1,1), X.reshape(-1,1), SX.reshape(-1,1)] # Grid points for prediction \n",
+    "\n",
+    "# Numerical traveltime\n",
+    "T_data = numerical_traveltime()\n",
+    "\n",
+    "# Plots\n",
+    "if args.model_type=='checkerboard':\n",
+    "    plot_section((6 + 6.5217391304347826*Z[:,:,0])/args.scale_factor, \"v_back.png\", save_dir=wandb.run.dir)\n",
+    "    plot_section(velpert[:,:,0]/args.scale_factor, \"v_pert.png\", save_dir=wandb.run.dir)\n",
+    "\n",
+    "# Interpolation\n",
+    "\n",
+    "Td_nn = np.zeros_like(T_data)\n",
+    "taudx_nn = np.zeros_like(T_data)\n",
+    "\n",
+    "Ti_data = np.zeros((len(x[id_rec_x])*len(id_sou_x)))\n",
+    "xri = np.tile(x[id_rec_x], len(id_sou_x))\n",
+    "zri = np.tile(z[id_rec_z], len(id_sou_z))\n",
+    "xsi = np.repeat(x[id_sou_x], len(id_rec_x))\n",
+    "zsi = np.repeat(z[id_sou_z], len(id_rec_z))\n",
+    "\n",
+    "for i in range(len(id_sou_x)):\n",
+    "    Ti_data[i*len(x[id_rec_x]):(i+1)*len(x[id_rec_x])] = T_data[id_rec_z,id_rec_x,i]\n",
+    "\n",
+    "rand_idx = np.random.permutation(np.arange(len(Ti_data)))\n",
+    "\n",
+    "X_ori = np.vstack((xri, zri, xsi, zsi)).T\n",
+    "y_ori = Ti_data\n",
+    "\n",
+    "X_all = X_ori[rand_idx,:]\n",
+    "y_all = y_ori[rand_idx]\n",
+    "\n",
+    "X_all = torch.from_numpy(X_all).float()\n",
+    "y_all = torch.from_numpy(y_all).float()\n",
+    "\n",
+    "X_ori = torch.from_numpy(X_ori).float()\n",
+    "\n",
+    "all_dataset = torch.utils.data.TensorDataset(X_all, y_all)\n",
+    "\n",
+    "# Use Pytorch's functionality to load data in batches. Here we use full-batch training again.\n",
+    "all_loader = torch.utils.data.DataLoader(all_dataset, batch_size=16, shuffle=True)\n",
+    "\n",
+    "if data_type=='nn':\n",
+    "    torch.manual_seed(8888)\n",
+    "    model = FullyConnectedNetwork(4, 1, n_hidden=[args.data_neurons]*args.data_layers, act='elu')\n",
+    "    # optimizer = torch.optim.Adam(model.parameters(), lr=5e-4) # best\n",
+    "    optimizer = torch.optim.Adam(model.parameters(), lr=2e-3)\n",
+    "    # scheduler = ReduceLROnPlateau(optimizer, mode='min', factor=0.5, patience=int(5*args.reduce_after), verbose=True)\n",
+    "    scheduler = ReduceLROnPlateau(optimizer, mode='min', factor=0.5, patience=int(4*args.reduce_after), verbose=True)\n",
+    "    criterion = torch.nn.MSELoss()\n",
+    "    model.train()\n",
+    "    loss_data = []\n",
+    "    for epoch in range(int(5e3)):\n",
+    "        total_loss = 0.\n",
+    "        model.train()\n",
+    "        loss = 0\n",
+    "        for x_i, y_i in all_loader:\n",
+    "            optimizer.zero_grad()\n",
+    "            yest = model(x_i).view(-1)\n",
+    "            loss = criterion(yest, y_i)\n",
+    "            loss.backward()\n",
+    "            optimizer.step()\n",
+    "            total_loss += loss.item()\n",
+    "        if epoch % 50 == 0 and epoch > 0:\n",
+    "            print(f'Epoch: {epoch}, Loss: {total_loss / X_all[:,0].detach().numpy().size}')\n",
+    "        mean_loss = total_loss / X_all[:,0].detach().numpy().size\n",
+    "        wandb.log({\"data_loss\": mean_loss})\n",
+    "        scheduler.step(mean_loss)\n",
+    "        loss_data.append(mean_loss)\n",
+    "\n",
+    "    Td_nn = np.zeros_like(T_data)\n",
+    "    X_all = [np.tile(x[id_top_x], len(sx)), np.tile(z[id_top_z], len(sz)), \n",
+    "             np.repeat(x[id_sou_x], len(x[id_top_x])), np.repeat(z[id_sou_z], len(z[id_top_z]))]\n",
+    "\n",
+    "    model.eval()\n",
+    "    Td_pred = model(torch.FloatTensor(X_all).T)\n",
+    "\n",
+    "    for i in range(len(id_sou_x)):\n",
+    "        Td_nn[:,:,i] = Td_pred[i*len(x):(i+1)*len(x)].detach().numpy().reshape(-1)\n",
+    "\n",
+    "    # Convergence history plot for verification\n",
+    "    fig = plt.figure()\n",
+    "    ax = plt.axes()\n",
+    "    ax.semilogy(loss_data)\n",
+    "\n",
+    "    ax.set_xlabel('Epochs',fontsize=14)\n",
+    "\n",
+    "    plt.xticks(fontsize=11)\n",
+    "\n",
+    "    ax.set_ylabel('Loss',fontsize=14)\n",
+    "    plt.yticks(fontsize=11);\n",
+    "    plt.grid()\n",
+    "    plt.savefig(os.path.join(wandb.run.dir, \"data_loss.png\"), format='png', bbox_inches=\"tight\")\n",
+    "\n",
+    "    # Save model\n",
+    "    torch.save({\n",
+    "            'model_state_dict': model.state_dict(),\n",
+    "            'optimizer_state_dict': optimizer.state_dict(),\n",
+    "            'loss': loss_data\n",
+    "    }, wandb.run.dir+'/saved_data_model')\n",
+    "\n",
+    "# Analytical solution for the known traveltime part\n",
+    "if args.depth_shift=='y':\n",
+    "    vs = args.initial_velocity #velmodel[np.round((SZ-5)/deltaz).astype(int),np.round(SX/deltax).astype(int),0]\n",
+    "else:\n",
+    "    vs = velmodel[np.round(SZ/deltaz).astype(int),np.round(SX/deltax).astype(int),0]\n",
+    "\n",
+    "T0 = np.sqrt((Z-SZ)**2 + (X-SX)**2)/vs;\n",
+    "px0 = np.divide(X-SX, T0*vs**2, out=np.zeros_like(T0), where=T0!=0)\n",
+    "pz0 = np.divide(Z-SZ, T0*vs**2, out=np.zeros_like(T0), where=T0!=0)\n",
+    "\n",
+    "if args.field_synthetic=='y':\n",
+    "    xf = np.arange(xmin,xmax+0.1*deltax,0.1*deltax)\n",
+    "    zf = np.arange(zmin,zmax+0.1*deltaz,0.1*deltaz)\n",
+    "    T_topo = np.zeros((len(zf), len(xf), len(id_sou_x)))\n",
+    "    for i in range(len(id_sou_x)):\n",
+    "        f = interpolate.interp2d(x, z, T_data[:,:,i], kind='cubic')\n",
+    "        T_topo[:,:,i] = f(xf, zf)\n",
+    "    id_top_x = []\n",
+    "    id_top_z = []\n",
+    "\n",
+    "    for h in range(len(xtop)):\n",
+    "\n",
+    "        for i in range(len(x)):\n",
+    "            if np.abs(xtop[h]-x[i])<1e-2:\n",
+    "                id_top_x.append(i)\n",
+    "\n",
+    "        for j in range(len(z)):    \n",
+    "            if np.abs(ztop[h]-z[j])<5e-3:\n",
+    "                id_top_z.append(j)\n",
+    "\n",
+    "    taud_topo = np.divide(T_data, T0, where=T0!=0)[id_top_z, id_top_x, :]\n",
+    "    T_topo = T_data[id_top_z, id_top_x, :]\n",
+    "\n",
+    "    taud_topo = np.repeat(taud_topo, nz).reshape(nx,len(id_sou_x),nz).swapaxes(1,2).swapaxes(0,1)\n",
+    "    T_topo = np.repeat(T_topo, nz).reshape(nx,len(id_sou_x),nz).swapaxes(1,2).swapaxes(0,1)\n",
+    "\n",
+    "Td_hc = np.zeros_like(T0)\n",
+    "T0_hc = np.zeros_like(T0)\n",
+    "taud_hc = np.zeros_like(T0)\n",
+    "taudx_hc = np.zeros_like(T0)\n",
+    "\n",
+    "for i in range(len(id_sou_x)):\n",
+    "    T0_hc[:,:,i] = np.tile(T0[0,:,i], nz).reshape(nz,nx)\n",
+    "\n",
+    "    # Numerical\n",
+    "    if data_type=='full':\n",
+    "        Td_hc[:,:,i] = np.tile(T_data[0,:,i], nz).reshape(nz,nx)\n",
+    "\n",
+    "    # NN-based interpolation\n",
+    "    elif data_type=='nn':\n",
+    "        Td_hc[:,:,i] = Td_nn[:,:,i].reshape(nz,nx)\n",
+    "\n",
+    "    if args.factorization_type=='multiplicative':   \n",
+    "        taud_hc[:,:,i] = np.divide(Td_hc[:,:,i], T0_hc[:,:,i], out=np.ones_like(T0_hc[:,:,i]), where=T0_hc[:,:,i]!=0)\n",
+    "    else:\n",
+    "        taud_hc[:,:,i] = Td_hc[:,:,i] - T0_hc[:,:,i]\n",
+    "\n",
+    "    # Numerical\n",
+    "    if data_type=='full':\n",
+    "        taudx_hc[:,:,i] = np.gradient(taud_hc.reshape(nz,nx,len(id_sou_x))[:,:,i], deltax, axis=1)\n",
+    "\n",
+    "    # NN-based interpolation\n",
+    "    elif data_type=='nn':\n",
+    "        taudx_hc[:,:,i] = np.gradient(taud_hc.reshape(nz,nx,len(id_sou_x))[:,:,i], deltax, axis=1)\n",
+    "\n",
+    "if args.field_synthetic=='y':\n",
+    "\n",
+    "    NAN = np.ones_like(X)\n",
+    "    for i in range(z.shape[0]):\n",
+    "        for j in range(x.shape[0]):\n",
+    "            if z[i] < Z[id_top_z, id_top_x, 0][j]:\n",
+    "                NAN[i,j,:] = float(\"Nan\")\n",
+    "                \n",
+    "# Interpolation check            \n",
+    "plot_int = len(id_sou_x)//5 if len(id_sou_x)>=5 else 1\n",
+    "for i in range(0, len(id_sou_x), plot_int):\n",
+    "    plot_section(T_data.reshape(nz,nx,len(id_sou_x))[:,:,i], 't_data_sou_'+str(i)+'_.png', 's', save_dir=wandb.run.dir, aspect='equal')\n",
+    "\n",
+    "    plt.figure()\n",
+    "    plt.scatter(x[id_rec_x], T_data[id_rec_z,id_rec_x,i], label='Data')\n",
+    "    plt.scatter(x[id_rec_x], Td_hc[id_rec_z,id_rec_x,i], label='Interpolated')\n",
+    "    plt.legend(['Data', 'Interpolation'])\n",
+    "    plt.savefig(os.path.join(wandb.run.dir, \"interpolation.png\"), format='png', bbox_inches=\"tight\")\n",
+    "\n",
+    "# locate source boolean\n",
+    "import time\n",
+    "start_time = time.time()\n",
+    "\n",
+    "TOLX = 1e-9\n",
+    "TOLZ = 1e-9\n",
+    "\n",
+    "sids = np.array([]).astype(int)\n",
+    "\n",
+    "for i in range(len(sx)):\n",
+    "    sid = np.where(((np.abs(Z.ravel()-sz[i])<TOLZ) & (np.abs(X.ravel()-sx[i])<TOLX) & (np.abs(SZ.ravel()-sz[i])<TOLZ) & (np.abs(SX.ravel()-sx[i])<TOLX))==True)[0]\n",
+    "    sids = np.append(sids,sid)    \n",
+    "\n",
+    "# locate source boolean\n",
+    "isource = np.ones_like(X_star[0]).reshape(-1,).astype(bool)\n",
+    "isource[sids] = False\n",
+    "\n",
+    "velmodel = velmodel.reshape(-1,1)\n",
+    "px0 = px0.reshape(-1,1)\n",
+    "pz0 = pz0.reshape(-1,1)\n",
+    "T0 = T0.reshape(-1,1)\n",
+    "T_data = T_data.reshape(-1,1)\n",
+    "\n",
+    "taud = taud_hc.reshape(-1,1)\n",
+    "if args.factorization_type=='multiplicative':\n",
+    "    taud[~isource] = 1.    \n",
+    "taudx = taudx_hc.reshape(-1,1)\n",
+    "index = torch.arange(T0.size)\n",
+    "\n",
+    "perm_id = np.random.permutation(X.size-sx.size)\n",
+    "\n",
+    "# xz, s, taud, taud_dz, t0, t0_dx, t0_dz in data_loader:\n",
+    "\n",
+    "input_wsrc = [X, Z, SX, taud, taudx, T0, px0, pz0, index]\n",
+    "input_wosrc = [i.ravel()[isource.reshape(-1)][perm_id] for i in input_wsrc]\n",
+    "if args.field_synthetic=='y':\n",
+    "    input_wonan = [i.ravel()[~np.isnan(NAN.ravel()[isource.reshape(-1)][perm_id])] for i in input_wosrc]\n",
+    "\n",
+    "# network\n",
+    "lay = 'linear'\n",
+    "ini = args.initialization\n",
+    "bias = 2\n",
+    "mean = 2\n",
+    "std = 1\n",
+    "opttype = 'adam'\n",
+    "lr = args.learning_rate\n",
+    "\n",
+    "# SciANN uses variance_scaling normal or Glorot (Xavier) normal for the weight initialization\n",
+    "# SciANN uses uniform for the bias initialization\n",
+    "\n",
+    "torch.manual_seed(seed)\n",
+    "if args.residual_network=='n':\n",
+    "    tau_model = FullyConnectedNetwork(3, 1, [args.num_neurons]*args.num_layers, last_act=args.tau_act, act=args.activation, lay=lay, last_multiplier=args.tau_multiplier)\n",
+    "else:\n",
+    "    tau_model = ResidualNetwork(3, 1, num_neurons=args.num_neurons, num_layers=args.num_layers, act=args.activation, lay=lay, last_multiplier=args.tau_multiplier)\n",
+    "tau_model.to(device)\n",
+    "\n",
+    "torch.manual_seed(seed)\n",
+    "if args.residual_network=='n':\n",
+    "    v_model = FullyConnectedNetwork(2, 1, [args.num_neurons//2]*args.num_layers, act=args.activation, lay=lay, last_act='relu', last_multiplier=args.v_multiplier)\n",
+    "else:\n",
+    "    v_model = ResidualNetwork(2, 1, num_neurons=args.num_neurons//2, act='relu', last_act='relu', num_layers=args.num_layers, lay=lay, last_multiplier=args.v_multiplier)\n",
+    "v_model.to(device)\n",
+    "v_model.apply(lambda m: init_weights(m, init_type=ini, bias=bias, mean=mean, std=std))\n",
+    "\n",
+    "# wandb.watch(tau_model, log_freq=100)\n",
+    "# wandb.watch(v_model, log_freq=100)\n",
+    "\n",
+    "perc = args.num_points\n",
+    "\n",
+    "if args.irregular_grid=='y':\n",
+    "    npoints = int(X.size * perc)\n",
+    "    ipermute = np.random.permutation(np.arange(X.size))[:npoints]\n",
+    "else:\n",
+    "    ipermute = None\n",
+    "\n",
+    "# Compute traveltime with randomly initialized network\n",
+    "pde_loader, ic = create_dataloader([i.ravel() for i in input_wsrc], sx, np.ones_like(sx)*sz.reshape(-1,),\n",
+    "                                   shuffle=False, fast_loader=True, perm_id=ipermute)\n",
+    "\n",
+    "if args.exp_function=='y':\n",
+    "    rec_op = (1-np.exp((Z.reshape(nz,nx,len(id_sou_x))-z[args.zid_receiver])**args.exp_factor))\n",
+    "else:\n",
+    "    rec_op = Z.reshape(nz,nx,len(id_sou_x))\n",
+    "\n",
+    "\n",
+    "if args.factorization_type=='multiplicative':\n",
+    "    tau_true = np.divide(\n",
+    "        T_data.reshape(nz,nx,len(id_sou_x)), \n",
+    "        T0.reshape(nz,nx,len(id_sou_x)), \n",
+    "        out=np.ones_like(T0.reshape(nz,nx,len(id_sou_x))), \n",
+    "        where=T0.reshape(nz,nx,len(id_sou_x))!=0\n",
+    "    )\n",
+    "    tau_true = tau_true - taud.reshape(nz,nx,len(id_sou_x))\n",
+    "    tau_true = np.divide(\n",
+    "        tau_true, \n",
+    "        rec_op, \n",
+    "        out=np.ones_like(Z.reshape(nz,nx,len(id_sou_x))), \n",
+    "        where=Z.reshape(nz,nx,len(id_sou_x))!=0\n",
+    "    )\n",
+    "    T_true = (rec_op*tau_true + taud.reshape(nz,nx,len(id_sou_x)))*T0.reshape(nz,nx,len(id_sou_x))\n",
+    "else:\n",
+    "    tau_true = T_data.reshape(nz,nx,len(id_sou_x)) - T0.reshape(nz,nx,len(id_sou_x)) - taud.reshape(nz,nx,len(id_sou_x))\n",
+    "    tau_true = np.divide(\n",
+    "        tau_true, \n",
+    "        rec_op, \n",
+    "        out=np.ones_like(Z.reshape(nz,nx,len(id_sou_x))), \n",
+    "        where=Z.reshape(nz,nx,len(id_sou_x))!=0\n",
+    "    )\n",
+    "    T_true = rec_op*tau_true + taud.reshape(nz,nx,len(id_sou_x)) + T0.reshape(nz,nx,len(id_sou_x))\n",
+    "\n",
+    "\n",
+    "v_init = evaluate_velocity(v_model, pde_loader)\n",
+    "tau_init = evaluate_tau(tau_model, pde_loader)\n",
+    "\n",
+    "elapsed = time.time() - start_time\n",
+    "print('Loading time: %.2f minutes' %(elapsed/60.))\n",
+    "\n",
+    "# Optimizer\n",
+    "if opttype == 'adam':\n",
+    "    optimizer = torch.optim.Adam(list(tau_model.parameters()) + list(v_model.parameters()), lr=lr, betas=(0.9, 0.999), eps=1e-5)\n",
+    "elif opttype == 'lbfgs':\n",
+    "    optimizer = torch.optim.LBFGS(list(tau_model.parameters()) + list(v_model.parameters()), line_search_fn=\"strong_wolfe\")\n",
+    "\n",
+    "# Scheduler\n",
+    "scheduler = ReduceLROnPlateau(optimizer, mode='min', factor=0.5, patience=args.reduce_after, verbose=True)\n",
+    "\n",
+    "plot_section(torch_to_numpy(v_init, nx, nz, len(id_sou_x))[:,:,0], \"v_init.png\", aspect='equal')\n",
+    "\n",
+    "for i in range(0, len(id_sou_x), plot_int):\n",
+    "    plot_section(torch_to_numpy(tau_init.reshape(Z.shape)[:,:,i], nx, nz, -1), \"tau_init_\"+str(i)+\".png\", 's/km', save_dir=wandb.run.dir, aspect='equal')\n",
+    "    plot_section(tau_true[:,:,i], \"tau_true_\"+str(i)+\".png\", 's/km', save_dir=wandb.run.dir, aspect='equal')\n",
+    "    plot_section(T_true[:,:,i], \"T_true_\"+str(i)+\".png\", 's', save_dir=wandb.run.dir, aspect='equal')\n",
+    "    plot_section(T_data.reshape(nz,nx,-1)[:,:,i], \"T_data_\"+str(i)+\".png\", 's', save_dir=wandb.run.dir, aspect='equal')    \n",
+    "\n",
+    "if data_type!='full':\n",
+    "    if args.field_synthetic=='y':\n",
+    "        for i in range(0, len(id_sou_x), plot_int):\n",
+    "            plot_horizontal(T_data.reshape(X.shape)[id_top_z,id_top_x,i], Td_nn[id_top_z,id_top_x,i], x*args.plotting_factor,'Interpolation Comparison','T (s)','T_comp_'+str(i)+'.png','True','NN', save_dir=wandb.run.dir)\n",
+    "            plot_horizontal(smooth(np.gradient(T_data.reshape(X.shape)[id_top_z,id_top_x,i]),2,'blackman'), np.gradient(Td_nn[id_top_z,id_top_x,i]), x*args.plotting_factor,'Interpolation Comparison','dT/dx (s/km)','Tdx_comp_'+str(i)+'.png','True','NN', save_dir=wandb.run.dir)\n",
+    "    else:\n",
+    "        for i in range(0, len(id_sou_x), plot_int):\n",
+    "            plot_horizontal(T_data.reshape(X.shape)[0,:,i], Td_nn[0,:,i], x*args.plotting_factor,'Interpolation Comparison','T (s)','T_comp_'+str(i)+'.png','True','NN', save_dir=wandb.run.dir)\n",
+    "            plot_horizontal(smooth(np.gradient(T_data.reshape(X.shape)[0,:,i]),2,'blackman'), np.gradient(Td_nn[0,:,i]), x*args.plotting_factor,'Interpolation Comparison','dT/dx (s/km)','Tdx_comp_'+str(i)+'.png','True','NN', save_dir=wandb.run.dir)"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "id": "7a2c9f90-0fae-478b-bfde-947299ad8e8d",
+   "metadata": {},
+   "outputs": [],
+   "source": []
+  },
   {
    "cell_type": "code",
    "execution_count": null,
-   "id": "d1db5870-edb7-4a9a-a723-caa0d132698f",
+   "id": "7076fd5b-dc27-4ba7-a100-6ea42500e395",
    "metadata": {},
    "outputs": [],
    "source": []
diff --git a/src/hcpinnseikonal/plot.py b/src/hcpinnseikonal/plot.py
index b2c1e8f..dc489bb 100644
--- a/src/hcpinnseikonal/plot.py
+++ b/src/hcpinnseikonal/plot.py
@@ -36,7 +36,8 @@ def plot_contour(pred, true, init, idx, fig_name=None, save_dir='./'):
                     format='png', bbox_inches="tight") 
 
 def plot_section(data, fig_name, data_type='km/s', vmin=None, vmax=None, 
-                 cmap='terrain', save_dir='./', aspect='equal'):
+                 cmap='terrain', save_dir='./', aspect='equal', 
+                 xmin=0, xmax=1, zmin=0, zmax=1):
     plt.figure()
     ax = plt.gca()
     im = ax.imshow(data, extent=[xmin,xmax,zmax,zmin], cmap=cmap, 
diff --git a/src/hcpinnseikonal/train.py b/src/hcpinnseikonal/train.py
index 16f2a22..4c97d9b 100644
--- a/src/hcpinnseikonal/train.py
+++ b/src/hcpinnseikonal/train.py
@@ -18,8 +18,7 @@ plt.rcParams['savefig.dpi'] = 300
 plt.rcParams['xtick.bottom'] = plt.rcParams['xtick.labelbottom'] = False
 plt.rcParams['xtick.top'] = plt.rcParams['xtick.labeltop'] = True
 plt.rcParams['figure.figsize'] =  [6.4, 4.8]
-        
-from argparse import ArgumentParser        
+           
 def numerical_traveltime():
     
     import pykonal
